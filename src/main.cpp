#include <ros/ros.h>
#include <pcl/ros/conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <image_transport/image_transport.h>
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/video/background_segm.hpp>
#include <pcl/io/pcd_io.h>
#include <Eigen/Dense>
#include <pcl_ros/point_cloud.h>
#include <pcl/visualization/cloud_viewer.h>
#include <pcl/common/transforms.h>

using namespace std;
using namespace cv;
using namespace Eigen;

float fx = 512, fy = 512, cx = 320, cy = 240;
Matrix3f camera_matrix;
Matrix4f t_mat, rotated;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat rgb_image,depth_image,output;


Mat readJPG(const char* input) {
    return imread(input);
}

Mat readPGM(const char* input) {
    return imread(input, CV_LOAD_IMAGE_ANYDEPTH);
}

pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGBA>);


void createPC() {
    if(!cloud->empty())
       cloud->clear();
    for( int y=0; y<480; y++) {
       for( int x=0; x<640; x++) {
          Scalar intensity = fgMaskMOG.at<uchar>(y,x);
          if (intensity.val[0]==255) {
             float d=(float)depth_image.at<ushort>(y,x);
             Vec3b color = rgb_image.at<Vec3b>(y,x);
             Vector4f temp;
             temp << x*d,y*d,d,1.0;
             Vector4f point = t_mat*temp;
             pcl::PointXYZRGBA  result;
             result.x = point(0);
             result.y = point(1);
             result.z = point(2);
             result.r = color.val[2];
             result.g = color.val[1];
             result.b = color.val[0];
             cloud->points.push_back(result);
          }
       }
    }
}



int main(int argc, char** argv) {
    ros::init (argc, argv, "pcl_homework");
    ros::NodeHandle n;

    char dir [] = "../dataset-kinect/";
    char rgbPrefix []= "rgb_";
    char depthPrefix []= "depth_";
    char jpgSuffix []= ".jpg";
    char pgmSuffix []= ".pgm";

    rotated << -1, 0, 0, 0,
                0, -1, 0, 0,
                0, 0, -1, 0,
                0, 0, 0, 1;

    camera_matrix<< fx, 0.0f, cx, 0.0f, fy, cy, 0.0f, 0.0f, 1.0f;
    t_mat.setIdentity();
    t_mat.block<3, 3>(0, 0) = camera_matrix.inverse();


    //Uncomment to show Mask Window
    namedWindow("Foreground", CV_WINDOW_AUTOSIZE);

    cvStartWindowThread();

    pcl::visualization::CloudViewer viewer ("Simple Cloud Viewer");

    //Uncomment to create Mask
    BackgroundSubtractorMOG PMOG(20, 4, 0.9);

    // Fill in the cloud data
    cloud->width    = 640;
    cloud->height   = 480;
    cloud->is_dense = false;
    cloud->points.resize (cloud->width * cloud->height);

    for( int i = 400; i < 550; i++ ) {
        char buffer1[100];
        char buffer2[100];
        sprintf(buffer1,"%s%s%d%s", dir, rgbPrefix, i, jpgSuffix);
        sprintf(buffer2,"%s%s%d%s", dir, depthPrefix, i, pgmSuffix);
        rgb_image = readJPG(buffer1);
        depth_image = readPGM(buffer2);

        //Calculate and show Mask
        PMOG(rgb_image,fgMaskMOG);
        imshow( "Foreground", fgMaskMOG );

        createPC();
        if(!viewer.wasStopped()){
            pcl::transformPointCloud( *cloud, *cloud, rotated);
            viewer.showCloud(cloud);
            ros::Duration(0.25, 0).sleep();
        }
    }

        waitKey(0);
        return 0;
}

